<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Crypto Ichimoku Dashboard</title>
  <script src="https://cdn.plot.ly/plotly-2.27.1.min.js"></script>
</head>
<body style="background-color:#111; color:white; font-family:sans-serif; text-align:center;">
  <h2>Crypto Ichimoku Dashboard</h2>

  <label for="cryptoSelect">Selecciona una cripto:</label>
  <select id="cryptoSelect">
    <option value="xrp">XRP</option>
    <option value="xlm">XLM</option>
    <option value="hbar">HBAR</option>
    <option value="dovu">DOVU</option>
    <option value="xdc">XDC</option>
    <option value="shx">SHX</option>
    <option value="velo">VELO</option>
    <option value="xdb">XDB</option>
    <option value="xpl">XPL</option>
    <option value="doge">DOGE</option>
    <option value="zbcn">ZBCN</option>
    <option value="paw">PAW</option>
    <option value="dag">DAG</option>
    <option value="xpr">XPR</option>
    <option value="qubic">QUBIC</option>
  </select>

  <label for="timeframeSelect" style="margin-left:20px;">Timeframe:</label>
  <select id="timeframeSelect">
    <option value="1h">1H</option>
    <option value="1d">1D</option>
  </select>

  <div id="chartContainer" style="width:90%; margin:auto; height:600px;"></div>

  <script>
    const cryptoSelect = document.getElementById("cryptoSelect");
    const timeframeSelect = document.getElementById("timeframeSelect");

    cryptoSelect.addEventListener("change", () => loadChart());
    timeframeSelect.addEventListener("change", () => loadChart());
    window.onload = () => loadChart();

    function calcularScore(d) {
      let score = 0;
      if (d.tenkan > d.kijun) score += 1.5;
      if (d.rsi > 50 && d.rsi < 70) score += 1;
      if (d.ewo > 0) score += 1.2;
      if (d.close > d.senkou_a && d.close > d.senkou_b) score += 2;
      if (d.close > d.sma_50 && d.sma_50 > d.sma_200) score += 2;
      if (d.rsi > 70) score -= 1;
      if (d.rsi < 30) score -= 1;
      return score;
    }

    // --- Detectar pivotes con ATR ---
    function detectarPivotes(data, lookback=5) {
      const pivotes = [];
      for (let i = lookback; i < data.length - lookback; i++) {
        const slice = data.slice(i - lookback, i + lookback + 1);
        const max = Math.max(...slice.map(d => d.close));
        const min = Math.min(...slice.map(d => d.close));
        const atr = data[i].atr;
        if (data[i].close === max && (max - min) > atr * 0.5) {
          pivotes.push({ type: 'high', ...data[i] });
        }
        if (data[i].close === min && (max - min) > atr * 0.5) {
          pivotes.push({ type: 'low', ...data[i] });
        }
      }
      return pivotes;
    }

    // --- Conteo básico de ondas Elliott ---
    function contarOndas(pivotes) {
      const ondas = [];
      let label = 1;
      for (let i = 0; i < pivotes.length; i++) {
        ondas.push({ ...pivotes[i], label });
        if (label === 5) label = 'A';
        else if (label === 'A') label = 'B';
        else if (label === 'B') label = 'C';
        else if (label === 'C') label = 1;
        else label++;
      }
      return ondas;
    }

    function loadChart() {
      const symbol = cryptoSelect.value;
      const timeframe = timeframeSelect.value;

      fetch(`/api/${symbol}_data?timeframe=${timeframe}`)
        .then(res => res.json())
        .then(response => {
          const data = response.data;
          const alerts = response.alerts;

          if (!data || data.length === 0) {
            document.getElementById("chartContainer").innerHTML = "No hay datos disponibles para esta cripto.";
            return;
          }

          const x = data.map(d => new Date(d.timestamp));
          const price = data.map(d => d.close);

          const traces = [
            {
              x,
              y: price,
              type: 'scatter',
              mode: 'lines',
              name: `Precio ${symbol.toUpperCase()}/USDT`,
              line: { color: '#00BFFF', width: 2 }
            },
            { x, y: data.map(d => d.tenkan), type: 'scatter', mode: 'lines', name: 'TENKAN', line: { color: 'blue' }, visible: 'legendonly' },
            { x, y: data.map(d => d.kijun), type: 'scatter', mode: 'lines', name: 'KIJUN', line: { color: 'green' }, visible: 'legendonly' },
            { x, y: data.map(d => d.senkou_a), type: 'scatter', mode: 'lines', name: 'SENKOU A', line: { color: 'orange' }, visible: 'legendonly' },
            { x, y: data.map(d => d.senkou_b), type: 'scatter', mode: 'lines', name: 'SENKOU B', line: { color: 'brown' }, visible: 'legendonly' },
            { x, y: data.map(d => d.vwap), type: 'scatter', mode: 'lines', name: 'VWAP', line: { color: 'purple' }, visible: 'legendonly' },
            { x, y: data.map(d => d.sma_50), type: 'scatter', mode: 'lines', name: 'SMA 50', line: { color: 'cyan' }, visible: 'legendonly' },
            { x, y: data.map(d => d.sma_200), type: 'scatter', mode: 'lines', name: 'SMA 200', line: { color: 'magenta' }, visible: 'legendonly' },
            { x, y: data.map(d => d.rsi), type: 'scatter', mode: 'lines', name: 'RSI', line: { color: 'yellow' }, visible: 'legendonly' },
            { x, y: data.map(d => d.atr), type: 'scatter', mode: 'lines', name: 'ATR', line: { color: 'red' }, visible: 'legendonly' },
            { x, y: data.map(d => d.ewo), type: 'scatter', mode: 'lines', name: 'EWO', line: { color: 'lime' }, visible: 'legendonly' }
          ];

          // --- Score actual ---
          const last = data[data.length - 1];
          const score = calcularScore(last);

          let direction = 0;
          if (score > 1.5) direction = 1;
          else if (score < -1.5) direction = -1;

          // --- Simulación de efectividad ---
          let aciertos = 0, total = 0;
          for (let i = 20; i < data.length - 6; i++) {
            const s = calcularScore(data[i]);
            const dir = s > 1.5 ? 1 : s < -1.5 ? -1 : 0;
            if (dir !== 0) {
              const real = data[i + 6].close;
              const esperado = data[i].close + (data[i+1].close - data[i].close) * dir;
              const error = Math.abs(real - esperado);
              if (error < data[i].atr * 1.2) aciertos++;
              total++;
            }
          }
          const efectividad = total > 0 ? Math.round((aciertos / total) * 100) : 0;

          // --- Proyección ---
          if (direction !== 0 && efectividad >= 60) {
            const lastTimestamp = new Date(last.timestamp);
            const lastPrices = data.slice(-10).map(d => d.close);
            const deltas = lastPrices.map((p, i, arr) => i > 0 ? p - arr[i - 1] : 0);
            const avgDelta = deltas.reduce((a, b) => a + b, 0) / deltas.length;
            const deltaFactor = timeframe === "1d" ? 1.5 : 1;

            const adjustedDeltaC = avgDelta * direction * deltaFactor;
            const adjustedDeltaA = avgDelta * direction * deltaFactor * 1.5;

            const colorC = direction === 1 ? 'rgba(0,100,0,0.4)' :
                           direction === -1 ? 'rgba(100,0,0,0.4)' :
                           'rgba(80,80,80,0.4)';

            const colorA = direction === 1 ? 'rgba(0,200,0,0.6)' :
                           direction === -1 ? 'rgba(200,0,0,0.6)' :
                           'rgba(150,150,150,0.6)';

            const futurePointsC = [];
            const futurePointsA = [];
            let priceC = last.close;
            let priceA = last.close;

            for (let i = 1; i <= 6; i++) {
              const nextTime = new Date(lastTimestamp);
              nextTime.setHours(nextTime.getHours() + i);
              priceC += adjustedDeltaC;
              priceA += adjustedDeltaA;
              futurePointsC.push({ x: nextTime, y: priceC });
              futurePointsA.push({ x: nextTime, y: priceA });
            }

            traces.push({
              x: futurePointsC.map(p => p.x),
              y: futurePointsC.map(p => p.y),
              type: 'scatter',
              mode: 'lines',
              name: 'Proyección conservadora',
              line: { color: colorC, dash: 'dot', width: 2, shape: 'spline' },
              opacity: 0.5,
              showlegend: true
            });

            traces.push({
              x: futurePointsA.map(p => p.x),
              y: futurePointsA.map(p => p.y),
              type: 'scatter',
              mode: 'lines',
              name: 'Proyección agresiva',
              line: { color: colorA, dash: 'dot', width: 2, shape: 'spline' },
              opacity: 0.6,
              showlegend: true
            });
          }

          // --- Pivotes con ATR ---
          const pivotes = detectarPivotes(data);
          if (pivotes.length > 0) {
            traces.push({
              x: pivotes.map(p => new Date(p.timestamp)),
              y: pivotes.map(p => p.close),
              mode: 'markers+text',
              type: 'scatter',
              name: 'Pivotes ATR',
              text: pivotes.map((p, i) => p.type === 'high' ? `▲${i}` : `▼${i}`),
              textposition: 'top center',
              marker: { color: 'white', size: 8, symbol: 'diamond' },
              visible: 'legendonly'
            });

            // --- Ondas Elliott básicas ---
            const ondas = contarOndas(pivotes);
            traces.push({
              x: ondas.map(o => new Date(o.timestamp)),
              y: ondas.map(o => o.close),
              mode: 'markers+text',
              type: 'scatter',
              name: 'Ondas Elliott',
              text: ondas.map(o => o.label),
              textposition: 'bottom center',
              marker: { color: 'gold', size: 10, symbol: 'circle' },
              visible: 'legendonly'
            });
          }

          const layout = {
            title: `${symbol.toUpperCase()} Indicadores Técnicos (${timeframe})`,
            xaxis: { title: 'Fecha y hora' },
            yaxis: { title: 'Valor', automargin: true },
            template: 'plotly_dark'
          };

          Plotly.newPlot('chartContainer', traces, layout);

          // --- Mostrar efectividad ---
          const oldEff = document.getElementById("effBox");
          if (oldEff) oldEff.remove();
          const effBox = document.createElement("div");
          effBox.id = "effBox";
          effBox.style.color = "#aaa";
          effBox.style.margin = "10px";
          effBox.innerHTML = `📈 Efectividad histórica estimada: <b>${efectividad}%</b>`;
          document.body.appendChild(effBox);

          // --- Mostrar alertas ---
          const oldAlert = document.getElementById("alertBox");
          if (oldAlert) oldAlert.remove();

          if (alerts && alerts.length > 0) {
            const alertBox = document.createElement("div");
            alertBox.id = "alertBox";
            alertBox.style.background = "#222";
            alertBox.style.color = "white";
            alertBox.style.padding = "10px";
            alertBox.style.margin = "10px auto";
            alertBox.style.width = "80%";
            alertBox.style.borderRadius = "8px";
            alertBox.style.fontSize = "16px";
            alertBox.style.textAlign = "left";
            alertBox.innerHTML = `<h3>📊 Señales detectadas:</h3>
              <ul>${alerts.map(a => `<li>${a}</li>`).join("")}</ul>`;
            document.body.appendChild(alertBox);
          }
        });
    }
  </script>
</body>
</html>
